.\" Automatically generated by Pod::Man version 1.15
.\" Fri Jul 19 17:23:56 2002
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "NonBlocking 3"
.TH NonBlocking 3 "perl v5.6.1" "2002-07-19" "User Contributed Perl Documentation"
.UC
.SH "NAME"
.Vb 1
\&        IO::NonBlocking - Object-oriented interface to non-blocking IO server implementation.
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&        package FooServer;
\&        use IO::NonBlocking;
\&        use strict;
\&        use vars qw (@ISA);
\&        @ISA=qw(IO::NonBlocking);
.Ve
.Vb 10
\&        sub new {
\&                my $class=ref($_[0]) || $_[0];
\&                my $self=IO::NonBlocking->new(
\&                                {
\&                                        server_name => 'FooServer',
\&                                        port => 52721,
\&                                        timeout => 300,
\&                                        piddir => '/tmp'
\&                                }
\&                        );
.Ve
.Vb 2
\&                bless $self,$class;
\&        }
.Ve
.Vb 3
\&        sub onClientConnected {
\&                my $self=shift;
\&                my $client=shift;
.Ve
.Vb 2
\&                print $self->getip($client),":",$self->getport($client),"\en";
\&        }
.Ve
.Vb 3
\&        sub onClientDisconnected {
\&                my $self=shift;
\&                my $client=shift;
.Ve
.Vb 2
\&                print "Disconnected\en";
\&        }
.Ve
.Vb 1
\&        1;
.Ve
.Vb 3
\&        package main;
\&        my $obj=FooServer->new;
\&        $obj->start;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1IO:\s0:NonBlocking is a non-blocking \s-1IO\s0 server style, runable on non-blocking \s-1IO\s0 capable \s-1OS\s0 \*(-- most Unix and it's cloned platforms.
.PP
The non-blocking server engine is built, basing on a page of codes of the Tom Christiansen's Perl Classic Cook Book.
.PP
If you have some experiences with \s-1IO:\s0:Multiplex, you'll see that the module has poor efficiency.
Since IO-multiplexing blocks all clients when one sends his data slowly. At first, I did appreciate the module much, 
but when user increases, everything is slowed down. 
.PP
After that, I had tried many fruitless improvement to the module and 
they didn't work at all. I'd realized that there weren't exist such a non-blocking server module on \s-1CPAN\s0, after mining for many nights. 
.PP
At last, I did copy a code from the Cook Book 
and it worked like charm at my first glance, nevertheless the code has some bugs 
that make my server crash, however, I've fixed it and plused many useful features to decide to release it as a module to \s-1CPAN\s0.
.Sh "Features"
.IX Subsection "Features"
.Ip "Inheritance only"
.IX Item "Inheritance only"
the purpose of this module is for inheritance only, it cannot do such a static call
.Ip "Timer"
.IX Item "Timer"
enable your server to execute sub routines at some configurable times
.Ip "Timeout"
.IX Item "Timeout"
Imagine a client is disconnected by his \s-1ISP\s0, by all means of \s-1TCP/IP\s0 , there's no way a server can notice about the disconnection in acceptable time.Timeout feature comes to handle this situation. You can set your server to autometically disconnect any clients who idle for \s-1XXX\s0 seconds
.Ip "Turn Timeout"
.IX Item "Turn Timeout"
If you plan to create a multi-player turn based game, maybe you need a time counter on server. Since time counter on client side is not secure. Probably a client can send his a fake timeout message to fool your server, if you do not manage this thing on server side.
.Sh "Usage"
.IX Subsection "Usage"
To implement a server service from this module, you have to inherit from it, something like this:
.PP
.Vb 3
\&        package FooServer;
\&        use IO::NonBlocking;
\&        @ISA=qw(IO::NonBlocking);
.Ve
.Vb 1
\&        1;
.Ve
.Vb 1
\&        package main;
.Ve
.Vb 5
\&        $obj=FooServer->new(
\&                {
\&                        'server_name' => 'FooServer',
\&                        'port' => 52721
\&                });
.Ve
.Vb 1
\&        $obj->start;
.Ve
and then, you can implement some methods to your modules to handle events which are:
.PP
.Vb 3
\&        sub onClientConnected{          # triggered when a client connect to server
\&                my $self=shift;
\&                my $client=shift;
.Ve
.Vb 1
\&        }
.Ve
.Vb 4
\&        sub onClientDisconnected{       # triggered when 
\&                                        # a client disconnect itself from yourserver
\&                my $self=shift;         # or the client is timeout
\&                my $client=shift;
.Ve
.Vb 1
\&        }
.Ve
.Vb 4
\&        sub onReceiveMessage{           # triggered when a client send a message to server
\&                my $self=shift;
\&                my $client=shift;
\&                my $request=shift;
.Ve
.Vb 1
\&        }
.Ve
The variable \f(CW$client\fR in every function above is socket handle of each client. You can write some data to it via print funcation as:
.PP
.Vb 1
\&        print $client "life is only temporary";
.Ve
but this isn't the only way you can send messages to a client. I've written message sender function, called sendmsg($client,$msg) to buffer outgoing data, to boost efficiency.
Let's see a sample code:
.PP
.Vb 3
\&        package FooServer;
\&        use IO::NonBlocking;
\&        @ISA=qw(IO::NonBlocking);
.Ve
.Vb 3
\&        sub onClientConnected {
\&                my $self=shift;
\&                my $client=shift;
.Ve
.Vb 2
\&                print "Connected ".$self->getip($client).":".$self->getport($client)."\en";
\&        }
.Ve
.Vb 3
\&        sub onClientDisconnected{
\&                my $self=shift;
\&                my $client=shift;
.Ve
.Vb 2
\&                print "Disconnected\en";
\&        }
.Ve
.Vb 4
\&       sub onReceiveMessage{
\&                my $self=shift;
\&                my $client=shift;
\&                my $request=shift;
.Ve
.Vb 3
\&                print $client "Hello ";
\&                $self->sendmsg($client,"World");
\&        }
.Ve
.Vb 1
\&        1;
.Ve
.Vb 1
\&        package main;
.Ve
.Vb 6
\&        $obj=FooServer->new(
\&               {
\&                        server_name => 'FooServer',
\&                        port => 52721,
\&                        delimiter => "\en"
\&                });
.Ve
.Vb 1
\&        $obj->start;
.Ve
The code should work fine on unix cloned platform.
Beside, you can pass, 'timeout' to the anonymous of constructor so that any client who is idle for a time you have configured will be autometically disconnected. By defaults 'timeout' is 300 seconds.
The following parameters are all of the constructor.
.PP
.Vb 6
\&        'server_name'   for name of server, you shouldn't leave blank
\&        'port'          the port where you want you server to reside in
\&        'delimiter'     the delimiter of you message of you protocol default is "\e0"
\&        'timeout'       timeout in second as I've stated, default is 300 second
\&        'piddir'        where pid file is kept, default is '/tmp' 
\&                        (all pid file is written in piddir with file name as "server_name"
.Ve
If you want to do some cron job with your server, the module provide cron($time,$refcode) for the requirement. Here is an example. ($time is in second)
.PP
.Vb 2
\&        sub kkk {
\&                my $self=shift;
.Ve
.Vb 2
\&                print "Ok, Computer\en";
\&        }
.Ve
.Vb 1
\&        $obj->cron(5,\e&kkk);
.Ve
If you create sub kkk in FooServer namespace, the above code will look like:
.PP
.Vb 1
\&        $obj->cron(5,\e&FooServer::kkk);
.Ve
The module pass every timer function with \f(CW$self\fR so that you can access you package variables.
.PP
Moreover, \s-1IO:\s0:NonBlocking give you turn timeout feature. You may not understand it at first, I'll explain. Imagine two client are playing online chess together, sooner or later a player of one side is disconnected for internet by his \s-1ISP\s0. In this circumstance, the chess server will not know the disconnection, because \s-1TCP\s0 give chances to a peer that cannot reachable. This process takes a long time. If the chess protocol counts times of each turn via client, the protocol fail in this case. Nevertheless, the problem is solved by counting time on server. I've provide 2 methods for this job. They are:
.PP
.Vb 2
\&        start_turn($client,$time);      start server counter for each client
\&        stop_time($client);             clear server counter for each client
.Ve
Whenever the counter is set, it continues decreasing 1 for each second. When the counter reach 0, the sub routine that you specifies triggered. For example:
.PP
.Vb 4
\&        sub kuay {
\&            my $self=shift;
\&            print $self->port,"\en";
\&        }
.Ve
.Vb 1
\&        my $toggle=0;
.Ve
.Vb 4
\&        sub onReceiveMessage {
\&            my $self=shift;
\&            my $client=shift;
\&            my $request=shift;
.Ve
.Vb 2
\&            print "Messeged\en";
\&            $toggle^=1;
.Ve
.Vb 6
\&            if ($toggle) {
\&                $self->start_turn($client,5,\e&kuay);
\&            } else {
\&                $self->stop_time($client);
\&            }
\&        }
.Ve
Caution, the timer of server is not as exactly as real clock, so I sync timer with the real clock at 4527 sec. This can lead to some bugs if your server is really relied on timer.
.Sh "METHODs"
.IX Subsection "METHODs"
.Ip "new (\e%hash)"
.IX Item "new (%hash)"
the hash referece comprise
\&'server_name' name of your server, it also the pid filename
\&'port' the port you want to listen
\&'delimiter' delimiter of your protocol message
\&'timeout' timeout of idle client
\&'piddir' directory where pid file is kept
.Ip "onClientConnected ($client)"
.IX Item "onClientConnected ($client)"
.Vb 2
\&      This method should be overrided. 
\&      It's triggered when a client connects to server.
.Ve
.Ip "onClientDisconnected ($client)"
.IX Item "onClientDisconnected ($client)"
.Vb 2
\&      This method should be overrided. 
\&      It's triggered when a client is disconnected, or disconnects itself from server.
.Ve
.Ip "onReceiveMessage ($client,$request)"
.IX Item "onReceiveMessage ($client,$request)"
.Vb 2
\&      This method should be overrided. 
\&      It's triggered when a client send a message to server.
.Ve
.Ip "start_turn ($client,$time,\e&code)"
.IX Item "start_turn ($client,$time,&code)"
.Vb 1
\&      Start, turn counter. See Usage;
.Ve
.Ip "stop_time ($client)"
.IX Item "stop_time ($client)"
.Vb 1
\&      Stop, turn counter. See Usage;
.Ve
.Ip "disconnect_client ($client)"
.IX Item "disconnect_client ($client)"
.Vb 1
\&      Force, disconnect a client from server.
.Ve
.Ip "start ()"
.IX Item "start ()"
.Vb 1
\&      When you setup every static such and such, you call this method to start listening.
.Ve
.Ip "getip ($client)"
.IX Item "getip ($client)"
.Vb 1
\&      Return ip address of one client.
.Ve
.Ip "getport ($client)"
.IX Item "getport ($client)"
.Vb 1
\&      Return port of one client.
.Ve
.Ip "piddir ()"
.IX Item "piddir ()"
.Vb 1
\&      Return piddir of server.
.Ve
.Ip "serverName ()"
.IX Item "serverName ()"
.Vb 1
\&      Return server_name of server.
.Ve
.Ip "port ()"
.IX Item "port ()"
.Vb 1
\&      Return port of server.
.Ve
.Ip "sendmsg ($client,$message)"
.IX Item "sendmsg ($client,$message)"
.Vb 1
\&      Send $message to outgoing buffer for $client
.Ve
.Ip "cron ($time,\e&code)"
.IX Item "cron ($time,&code)"
.Vb 1
\&      Install timer triggered function. see Usage.
.Ve
.Sh "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None.
.SH "AUTHOR"
.IX Header "AUTHOR"
Komtanoo  Pinpimai <romerun@romerun.com>, yet another \s-1CP24\s0, Bangkok, Thailand.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002 (c) Komtanoo  Pinpimai <romerun@romerun.com>, yet another \s-1CP24\s0, Bangkok, Thailand. All rights reserved.
